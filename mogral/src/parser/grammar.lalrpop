use std::str::FromStr;
use crate::ast;
use crate::pos::{Span, Spanned};
use crate::op::Op;
use crate::types::MglType;

grammar;

pub Module:                                 ast::Module = {
    Sp<Func>*                                   => ast::Module { funcs: <> },
};

// Function

Func:                                       ast::Func = {
    "extern" <FuncDecl> ";"                     => ast::Func::Extern(<>),
    FuncDef                                     => ast::Func::FuncDef(<>),
};
FuncDecl:                                   ast::FuncDecl = {
    "fn" <n:Sp<Ident>> "(" <p:Params> ")"
        <r:FuncRetType?>                        => ast::FuncDecl { name: n, params: p, ret: r },
};
FuncRetType:                                Spanned<MglType> = {
    ":" <Sp<Type>>
};

Params = Comma<Sp<TypedIdent>>;
FuncDef:                                    ast::FuncDef = {
    <d:Sp<FuncDecl>> <b:Sp<Block>>              => ast::FuncDef { decl: d, body: b },
};

// Statements

Stmt:                                       ast::Stmt = {
    <Sp<Assign>> ";"                            => ast::Stmt::Assign(<>),
    <Sp<Expr>> ";"                              => ast::Stmt::Expr(<>),
};

Assign:                                     ast::Assign = {
    <i:Sp<Ident>> "=" <e:Sp<Expr>>              => ast::Assign { var_name: i, val: e },
};

// Expressions

Expr:                                       Box<ast::Expr> = {
    Set                                         => Box::new(ast::Expr::Set(<>)),
    Return                                      => Box::new(ast::Expr::Return(<>)),
    OpExpr,
};

Set:                                        ast::Assign = {
    "set" <Assign>,
};

Return:                                     Box<ast::Expr> = {
    "return" <Expr>,
};

OpExpr = Tier<CompOp, AddExpr>;
AddExpr = Tier<AddOp, MulExpr>;
MulExpr = Tier<MulOp, Primary>;

Primary:                                    Box<ast::Expr> = {
    Literal                                     => Box::new(ast::Expr::Literal(<>)),
    Ident                                       => Box::new(ast::Expr::Ident(<>)),
    FuncCall                                    => Box::new(ast::Expr::FuncCall(<>)),
    "(" <Expr> ")",
    ExprWithBlock,
};

FuncCall:                                   ast::FuncCall = {
    <i:Sp<Ident>> "(" <a:ArgList> ")"           => ast::FuncCall { func_name: i, args: a },
};
ArgList = Comma<Sp<Expr>>;

ExprWithBlock:                              Box<ast::Expr> = {
    Block                                       => Box::new(ast::Expr::Block(<>)),
    If                                          => Box::new(ast::Expr::If(<>)),
    For                                         => Box::new(ast::Expr::For(<>)),
};

Block:                                      ast::Block = {
    "{" <mut v:Sp<StmtsInBlock>*> <s:Sp<Stmt>>
        "}"                                     => { v.push(s); ast::Block { stmts: v, expr: None } },
    "{" <v:Sp<StmtsInBlock>*> <e:Sp<Expr>> "}"  => ast::Block { stmts: v, expr: Some(e) },
    "{" "}"                                     => ast::Block { stmts: Vec::new(), expr: None },
};
StmtsInBlock:                               ast::Stmt = {
    Stmt,
    Sp<ExprWithBlock>                           => ast::Stmt::Expr(<>)
};

If:                                         ast::If = {
    "if" <c:Sp<Expr>> <t:Sp<Block>>
        <e:Else?>                               => ast::If { cond: c, then: t, else_: e },
};
Else:                                       Spanned<ast::Block> = {
    "else" <Sp<Block>>,
};

For:                                        ast::For = {
    "for" <v:Sp<Ident>> "," <u:Sp<Expr>>
        <b:Sp<Block>>                           => ast::For { var_name: v, until: u, body: b },
};

TypedIdent:                                 ast::TypedIdent = {
    <i:Sp<Ident>> ":" <t:Sp<Type>>              => ast::TypedIdent { ident: i, type_: t },
}

CompOp:                                     Op = {
    "<"                                         => Op::Lt,
    ">"                                         => Op::Gt,
    "<="                                        => Op::Leq,
    ">="                                        => Op::Geq,
    "=="                                        => Op::Eq,
    "!="                                        => Op::Neq,
};
AddOp:                                      Op = {
    "+"                                         => Op::Add,
    "-"                                         => Op::Sub,
};
MulOp:                                      Op = {
    "*"                                         => Op::Mul,
    "/"                                         => Op::Div,
};

Ident:                                      String = {
    r"[A-Za-z_][A-Za-z_0-9]*"                   => <>.to_string()
};

Literal:                                    ast::Literal = {
    Unit                                        => ast::Literal::Unit(<>),
    Number                                      => ast::Literal::Float(<>),
    Bool                                        => ast::Literal::Bool(<>),
};

Unit:                                       () = {
    "(" ")"                                     => (),
}

Number:                                     f64 = {
    Integer,
    Float,
}
Integer:                                    f64 = {
    r"0|[1-9][0-9]*"                            => f64::from_str(<>).unwrap(),
}
Float:                                      f64 = {
    r"(0?|[1-9][0-9]*)\.[0-9]+"                 => f64::from_str(<>).unwrap(),
}

Bool:                                       bool = {
    "true"                                      => true,
    "false"                                     => false,
}

Type:                                       MglType = {
    "(" ")"                                     => MglType::Unit,
    "double"                                    => MglType::Double,
    "bool"                                      => MglType::Bool,
}

Comma<T>:                                   Vec<T> = {
    <mut v:(<T> ",")*> <e:T?>                   => match e {
                                                    None => v,
                                                    Some(e) => {
                                                        v.push(e);
                                                        v
                                                    }
                                                }
};

Tier<Op, NextTier>:                         Box<ast::Expr> = {
    <l:Sp<Tier<Op, NextTier>>> <o:Sp<Op>>
        <r:Sp<NextTier>>                        => Box::new(ast::Expr::Op(ast::OpExpr { lhs: l, op: o, rhs: r })),
    NextTier
};

#[inline]
Sp<Rule>:                                   Spanned<Rule> = {
    <l:@L> <i:Rule> <r:@R>                      => Spanned { item: i, span: Span { l, r } }
};
